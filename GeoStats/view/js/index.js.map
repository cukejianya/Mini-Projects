{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","node_modules/browserify/node_modules/process/browser.js","index.js","node_modules/d.js/lib/D.js","view/js/ajax.js","view/js/initMap.js","view/js/main.js","view/js/plotGenderAge.js","view/js/plotRace.js","view/js/plotTotal.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","cleanUpNextTick","draining","currentQueue","queue","concat","queueIndex","drainQueue","timeout","setTimeout","len","run","clearTimeout","Item","fun","array","this","noop","process","nextTick","args","Array","arguments","push","prototype","apply","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","name","cwd","chdir","dir","umask",2,"undef","rethrow","promise_success","fulfilled","then","promise_error","failed","promise_apply","isFunc","isArray","defer","onlyFuncs","promise_ensure","cb","_cb","promise_nodify","splice","undefined","promise_rethrow","multiPromiseResolver","callerArguments","returnPromises","promises","slice","d","c","resolver","promisify","v","resolve","reject","promise","sequenceZenifier","zenValue","sequencePromiseResolver","funcs","resolved","isObjOrFunc","match","isNotVal","offset","undefStr","tErr","TypeError","MessageChannel","ntickChannel","port1","onmessage","shift","port2","postMessage","alwaysAsync","execCallbacks","status","cbs","pendings","cbIndex","value","_resolve","val","x","done","_promise","_reject","alwaysAsyncFn","Err","fn","err","success","error","otherwise","spread","ensure","nodify","isPending","getStatus","toSource","toString","valueOf","fulfill","deferred","rejected","reason","wait","time","delay","all","resolveAll","sequence","nodeCapsule","subject","res","define","amd","window","oldD","D","noConflict","_process",3,"serRequest","geolocate","$","ajax","type","url","data","JSON","parse","jqXHR","textstatus","errorThrown","console","log","d.js",4,"offsetMap","latlng","offsetx","offsety","scale","Math","pow","map","getZoom","worldCoordinateCenter","google","maps","LatLng","getBounds","getNorthEast","lat","getSouthWest","lng","getProjection","fromLatLngToPoint","pixelOffset","Point","worldCoordinateNewCenter","y","newCenter","fromPointToLatLng","setCenter","initMap","Map","document","getElementById","center","zoom","input","options","componentRestrictions","country","autocomplete","places","Autocomplete","infowindow","InfoWindow","maxWidth","marker","Marker","open","close","place","getPlace","geometry","address_components","location","types","viewport","fitBounds","setZoom","setPlace","placeId","place_id","setVisible","setContent","formatted_address",5,"createPlot","censusData","totalHTML","d3","select","raceHTML","genderAgeHTML","totalData","race","total","raceData","femaleData","femaleAge","maleData","maleAge","needToRemove","removePlot","plotTotal","plotRace","plotGenderAge","remove","selectAll","promiseChain","request","bindedCreatePlot","bind","resize","ready","./ajax","./initMap","./plotGenderAge","./plotRace","./plotTotal",6,"div","genderAge","change","transitionStacked","transitionGrouped","yGroupMax","rect","height","keys","domain","transition","duration","attr","j","rangeBand","yStackMax","y0","Object","stack","layout","layers","range","idx","max","parseInt","layer","color","node","parentElement","linear","tableCategories","unshift","mainSelection","tr","enter","append","selection","text","margin","top","right","bottom","left","width","ordinal","rangeRoundBands","xAxis","svg","axis","tickSize","tickPadding","orient","style","property","each",7,"filter","key","category20","str","split","elm","toUpperCase","join","outerRadius","innerRadius","arc","pie","ease","path","timer","elapsed","abs","arcs","padAngle",8],"mappings":"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","file":"index.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],2:[function(require,module,exports){\n(function (process){\n/**\n* attempt of a simple defer/promise library for mobile development\n* @author Jonathan Gotti < jgotti at jgotti dot net>\n* @since 2012-10\n* @version 0.7.3\n*/\n(function(undef){\n\t\"use strict\";\n\n\tvar nextTick\n\t\t, isFunc = function(f){ return ( typeof f === 'function' ); }\n\t\t, isArray = function(a){ return Array.isArray ? Array.isArray(a) : (a instanceof Array); }\n\t\t, isObjOrFunc = function(o){ return !!(o && (typeof o).match(/function|object/)); }\n\t\t, isNotVal = function(v){ return (v === false || v === undef || v === null); }\n\t\t, slice = function(a, offset){ return [].slice.call(a, offset); }\n\t\t, undefStr = 'undefined'\n\t\t, tErr = typeof TypeError === undefStr ? Error : TypeError\n\t;\n\tif ( (typeof process !== undefStr) && process.nextTick ) {\n\t\tnextTick = process.nextTick;\n\t} else if ( typeof MessageChannel !== undefStr ) {\n\t\tvar ntickChannel = new MessageChannel(), queue = [];\n\t\tntickChannel.port1.onmessage = function(){ queue.length && (queue.shift())(); };\n\t\tnextTick = function(cb){\n\t\t\tqueue.push(cb);\n\t\t\tntickChannel.port2.postMessage(0);\n\t\t};\n\t} else {\n\t\tnextTick = function(cb){ setTimeout(cb, 0); };\n\t}\n\tfunction rethrow(e){ nextTick(function(){ throw e;}); }\n\n\t/**\n\t * @typedef deferred\n\t * @property {promise} promise\n\t * @method resolve\n\t * @method fulfill\n\t * @method reject\n\t */\n\n\t/**\n\t * @typedef {function} fulfilled\n\t * @param {*} value promise resolved value\n\t * @returns {*} next promise resolution value\n\t */\n\n\t/**\n\t * @typedef {function} failed\n\t * @param {*} reason promise rejection reason\n\t * @returns {*} next promise resolution value or rethrow the reason\n\t */\n\n\t//-- defining unenclosed promise methods --//\n\t/**\n\t * same as then without failed callback\n\t * @param {fulfilled} fulfilled callback\n\t * @returns {promise} a new promise\n\t */\n\tfunction promise_success(fulfilled){ return this.then(fulfilled, undef); }\n\n\t/**\n\t * same as then with only a failed callback\n\t * @param {failed} failed callback\n\t * @returns {promise} a new promise\n\t */\n\tfunction promise_error(failed){ return this.then(undef, failed); }\n\n\n\t/**\n\t * same as then but fulfilled callback will receive multiple parameters when promise is fulfilled with an Array\n\t * @param {fulfilled} fulfilled callback\n\t * @param {failed} failed callback\n\t * @returns {promise} a new promise\n\t */\n\tfunction promise_apply(fulfilled, failed){\n\t\treturn this.then(\n\t\t\tfunction(a){\n\t\t\t\treturn isFunc(fulfilled) ? fulfilled.apply(null, isArray(a) ? a : [a]) : (defer.onlyFuncs ? a : fulfilled);\n\t\t\t}\n\t\t\t, failed || undef\n\t\t);\n\t}\n\n\t/**\n\t * cleanup method which will be always executed regardless fulfillment or rejection\n\t * @param {function} cb a callback called regardless of the fulfillment or rejection of the promise which will be called\n\t *                      when the promise is not pending anymore\n\t * @returns {promise} the same promise untouched\n\t */\n\tfunction promise_ensure(cb){\n\t\tfunction _cb(){ cb(); }\n\t\tthis.then(_cb, _cb);\n\t\treturn this;\n\t}\n\n\t/**\n\t * take a single callback which wait for an error as first parameter. other resolution values are passed as with the apply/spread method\n\t * @param {function} cb a callback called regardless of the fulfillment or rejection of the promise which will be called\n\t *                      when the promise is not pending anymore with error as first parameter if any as in node style\n\t *                      callback. Rest of parameters will be applied as with the apply method.\n\t * @returns {promise} a new promise\n\t */\n\tfunction promise_nodify(cb){\n\t\treturn this.then(\n\t\t\tfunction(a){\n\t\t\t\treturn isFunc(cb) ? cb.apply(null, isArray(a) ? a.splice(0,0,undefined) && a : [undefined,a]) : (defer.onlyFuncs ? a : cb);\n\t\t\t}\n\t\t\t, function(e){\n\t\t\t\treturn cb(e);\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t *\n\t * @param {function} [failed] without parameter will only rethrow promise rejection reason outside of the promise library on next tick\n\t *                            if passed a failed method then will call failed on rejection and throw the error again if failed didn't\n\t * @returns {promise} a new promise\n\t */\n\tfunction promise_rethrow(failed){\n\t\treturn this.then(\n\t\t\tundef\n\t\t\t, failed ? function(e){ failed(e); throw e; } : rethrow\n\t\t);\n\t}\n\n\t/**\n\t* @param {boolean} [alwaysAsync] if set force the async resolution for this promise independantly of the D.alwaysAsync option\n\t* @returns {deferred} defered object with property 'promise' and methods reject,fulfill,resolve (fulfill being an alias for resolve)\n\t*/\n\tvar defer = function (alwaysAsync){\n\t\tvar alwaysAsyncFn = (undef !== alwaysAsync ? alwaysAsync : defer.alwaysAsync) ? nextTick : function(fn){fn();}\n\t\t\t, status = 0 // -1 failed | 1 fulfilled\n\t\t\t, pendings = []\n\t\t\t, value\n\t\t\t/**\n\t\t\t * @typedef promise\n\t\t\t */\n\t\t\t, _promise  = {\n\t\t\t\t/**\n\t\t\t\t * @param {fulfilled|function} fulfilled callback\n\t\t\t\t * @param {failed|function} failed callback\n\t\t\t\t * @returns {promise} a new promise\n\t\t\t\t */\n\t\t\t\tthen: function(fulfilled, failed){\n\t\t\t\t\tvar d = defer();\n\t\t\t\t\tpendings.push([\n\t\t\t\t\t\tfunction(value){\n\t\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\t\tif( isNotVal(fulfilled)){\n\t\t\t\t\t\t\t\t\td.resolve(value);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\td.resolve(isFunc(fulfilled) ? fulfilled(value) : (defer.onlyFuncs ? value : fulfilled));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}catch(e){\n\t\t\t\t\t\t\t\td.reject(e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t, function(err){\n\t\t\t\t\t\t\tif ( isNotVal(failed) || ((!isFunc(failed)) && defer.onlyFuncs) ) {\n\t\t\t\t\t\t\t\td.reject(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( failed ) {\n\t\t\t\t\t\t\t\ttry{ d.resolve(isFunc(failed) ? failed(err) : failed); }catch(e){ d.reject(e);}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t]);\n\t\t\t\t\tstatus !== 0 && alwaysAsyncFn(execCallbacks);\n\t\t\t\t\treturn d.promise;\n\t\t\t\t}\n\n\t\t\t\t, success: promise_success\n\n\t\t\t\t, error: promise_error\n\t\t\t\t, otherwise: promise_error\n\n\t\t\t\t, apply: promise_apply\n\t\t\t\t, spread: promise_apply\n\n\t\t\t\t, ensure: promise_ensure\n\n\t\t\t\t, nodify: promise_nodify\n\n\t\t\t\t, rethrow: promise_rethrow\n\n\t\t\t\t, isPending: function(){ return status === 0; }\n\n\t\t\t\t, getStatus: function(){ return status; }\n\t\t\t}\n\t\t;\n\t\t_promise.toSource = _promise.toString = _promise.valueOf = function(){return value === undef ? this : value; };\n\n\n\t\tfunction execCallbacks(){\n\t\t\t/*jshint bitwise:false*/\n\t\t\tif ( status === 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar cbs = pendings, i = 0, l = cbs.length, cbIndex = ~status ? 0 : 1, cb;\n\t\t\tpendings = [];\n\t\t\tfor( ; i < l; i++ ){\n\t\t\t\t(cb = cbs[i][cbIndex]) && cb(value);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * fulfill deferred with given value\n\t\t * @param {*} val\n\t\t * @returns {deferred} this for method chaining\n\t\t */\n\t\tfunction _resolve(val){\n\t\t\tvar done = false;\n\t\t\tfunction once(f){\n\t\t\t\treturn function(x){\n\t\t\t\t\tif (done) {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdone = true;\n\t\t\t\t\t\treturn f(x);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\tif ( status ) {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tvar then = isObjOrFunc(val) && val.then;\n\t\t\t\tif ( isFunc(then) ) { // managing a promise\n\t\t\t\t\tif( val === _promise ){\n\t\t\t\t\t\tthrow new tErr(\"Promise can't resolve itself\");\n\t\t\t\t\t}\n\t\t\t\t\tthen.call(val, once(_resolve), once(_reject));\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tonce(_reject)(e);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\talwaysAsyncFn(function(){\n\t\t\t\tvalue = val;\n\t\t\t\tstatus = 1;\n\t\t\t\texecCallbacks();\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * reject deferred with given reason\n\t\t * @param {*} Err\n\t\t * @returns {deferred} this for method chaining\n\t\t */\n\t\tfunction _reject(Err){\n\t\t\tstatus || alwaysAsyncFn(function(){\n\t\t\t\ttry{ throw(Err); }catch(e){ value = e; }\n\t\t\t\tstatus = -1;\n\t\t\t\texecCallbacks();\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\t\treturn /**@type deferred */ {\n\t\t\tpromise:_promise\n\t\t\t,resolve:_resolve\n\t\t\t,fulfill:_resolve // alias\n\t\t\t,reject:_reject\n\t\t};\n\t};\n\n\tdefer.deferred = defer.defer = defer;\n\tdefer.nextTick = nextTick;\n\tdefer.alwaysAsync = true; // setting this will change default behaviour. use it only if necessary as asynchronicity will force some delay between your promise resolutions and is not always what you want.\n\t/**\n\t* setting onlyFuncs to false will break promises/A+ conformity by allowing you to pass non undefined/null values instead of callbacks\n\t* instead of just ignoring any non function parameters to then,success,error... it will accept non null|undefined values.\n\t* this will allow you shortcuts like promise.then('val','handled error'')\n\t* to be equivalent of promise.then(function(){ return 'val';},function(){ return 'handled error'})\n\t*/\n\tdefer.onlyFuncs = true;\n\n\t/**\n\t * return a fulfilled promise of given value (always async resolution)\n\t * @param {*} value\n\t * @returns {promise}\n\t */\n\tdefer.resolved = defer.fulfilled = function(value){ return defer(true).resolve(value).promise; };\n\n\t/**\n\t * return a rejected promise with given reason of rejection (always async rejection)\n\t * @param {*} reason\n\t * @returns {promise}\n\t */\n\tdefer.rejected = function(reason){ return defer(true).reject(reason).promise; };\n\n\t/**\n\t * return a promise with no resolution value which will be resolved in time ms (using setTimeout)\n\t * @param {int} [time] in ms default to 0\n\t * @returns {promise}\n\t */\n\tdefer.wait = function(time){\n\t\tvar d = defer();\n\t\tsetTimeout(d.resolve, time || 0);\n\t\treturn d.promise;\n\t};\n\n\t/**\n\t * return a promise for the return value of function call which will be fulfilled in delay ms or rejected if given fn throw an error\n\t * @param {*} fn to execute or value to return after given delay\n\t * @param {int} [delay] in ms default to 0\n\t * @returns {promise}\n\t */\n\tdefer.delay = function(fn, delay){\n\t\tvar d = defer();\n\t\tsetTimeout(function(){ try{ d.resolve(isFunc(fn) ? fn.apply(null) : fn); }catch(e){ d.reject(e); } }, delay || 0);\n\t\treturn d.promise;\n\t};\n\n\t/**\n\t * if given value is not a promise return a fulfilled promise resolved to given value\n\t * @param {*} promise a value or a promise\n\t * @returns {promise}\n\t */\n\tdefer.promisify = function(promise){\n\t\tif ( promise && isFunc(promise.then) ) { return promise;}\n\t\treturn defer.resolved(promise);\n\t};\n\n\tfunction multiPromiseResolver(callerArguments, returnPromises){\n\t\tvar promises = slice(callerArguments);\n\t\tif ( promises.length === 1 && isArray(promises[0]) ) {\n\t\t\tif(! promises[0].length ){\n\t\t\t\treturn defer.fulfilled([]);\n\t\t\t}\n\t\t\tpromises = promises[0];\n\t\t}\n\t\tvar args = []\n\t\t\t, d = defer()\n\t\t\t, c = promises.length\n\t\t;\n\t\tif ( !c ) {\n\t\t\td.resolve(args);\n\t\t} else {\n\t\t\tvar resolver = function(i){\n\t\t\t\tpromises[i] = defer.promisify(promises[i]);\n\t\t\t\tpromises[i].then(\n\t\t\t\t\tfunction(v){\n\t\t\t\t\t\targs[i] = returnPromises ? promises[i] : v;\n\t\t\t\t\t\t(--c) || d.resolve(args);\n\t\t\t\t\t}\n\t\t\t\t\t, function(e){\n\t\t\t\t\t\tif( ! returnPromises ){\n\t\t\t\t\t\t\td.reject(e);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\targs[i] = promises[i];\n\t\t\t\t\t\t\t(--c) || d.resolve(args);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t};\n\t\t\tfor( var i = 0, l = c; i < l; i++ ){\n\t\t\t\tresolver(i);\n\t\t\t}\n\t\t}\n\t\treturn d.promise;\n\t}\n\n\tfunction sequenceZenifier(promise, zenValue){\n\t\treturn promise.then(isFunc(zenValue) ? zenValue : function(){return zenValue;});\n\t}\n\tfunction sequencePromiseResolver(callerArguments){\n\t\tvar funcs = slice(callerArguments);\n\t\tif ( funcs.length === 1 && isArray(funcs[0]) ) {\n\t\t\tfuncs = funcs[0];\n\t\t}\n\t\tvar d = defer(), i=0, l=funcs.length, promise = defer.resolved();\n\t\tfor(; i<l; i++){\n\t\t\tpromise = sequenceZenifier(promise, funcs[i]);\n\t\t}\n\t\td.resolve(promise);\n\t\treturn d.promise;\n\t}\n\n\t/**\n\t * return a promise for all given promises / values.\n\t * the returned promises will be fulfilled with a list of resolved value.\n\t * if any given promise is rejected then on the first rejection the returned promised will be rejected with the same reason\n\t * @param {array|...*} [promise] can be a single array of promise/values as first parameter or a list of direct parameters promise/value\n\t * @returns {promise} of a list of given promise resolution value\n\t */\n\tdefer.all = function(){ return multiPromiseResolver(arguments,false); };\n\n\t/**\n\t * return an always fulfilled promise of array<promise> list of promises/values regardless they resolve fulfilled or rejected\n\t * @param {array|...*} [promise] can be a single array of promise/values as first parameter or a list of direct parameters promise/value\n\t *                     (non promise values will be promisified)\n\t * @returns {promise} of the list of given promises\n\t */\n\tdefer.resolveAll = function(){ return multiPromiseResolver(arguments,true); };\n\n\t/**\n\t* execute given function in sequence passing their returned values to the next one in sequence.\n\t* You can pass values or promise instead of functions they will be passed in the sequence as if a function returned them.\n\t* if any function throw an error or a rejected promise the final returned promise will be rejected with that reason.\n\t* @param {array|...*} [function] list of function to call in sequence receiving previous one as a parameter\n\t*                     (non function values will be treated as if returned by a function)\n\t* @returns {promise} of the list of given promises\n\t*/\n\tdefer.sequence = function(){ return sequencePromiseResolver(arguments); };\n\n\t/**\n\t * transform a typical nodejs async method awaiting a callback as last parameter, receiving error as first parameter to a function that\n\t * will return a promise instead. the returned promise will resolve with normal callback value minus the first error parameter on\n\t * fulfill and will be rejected with that error as reason in case of error.\n\t * @param {object} [subject] optional subject of the method to encapsulate\n\t * @param {function} fn the function to encapsulate if the normal callback should receive more than a single parameter (minus the error)\n\t *                      the promise will resolve with the list or parameters as fulfillment value. If only one parameter is sent to the\n\t *                      callback then it will be used as the resolution value.\n\t * @returns {Function}\n\t */\n\tdefer.nodeCapsule = function(subject, fn){\n\t\tif ( !fn ) {\n\t\t\tfn = subject;\n\t\t\tsubject = void(0);\n\t\t}\n\t\treturn function(){\n\t\t\tvar d = defer(), args = slice(arguments);\n\t\t\targs.push(function(err, res){\n\t\t\t\terr ? d.reject(err) : d.resolve(arguments.length > 2 ? slice(arguments, 1) : res);\n\t\t\t});\n\t\t\ttry{\n\t\t\t\tfn.apply(subject, args);\n\t\t\t}catch(e){\n\t\t\t\td.reject(e);\n\t\t\t}\n\t\t\treturn d.promise;\n\t\t};\n\t};\n\n\t/*global define*/\n\tif ( typeof define === 'function' && define.amd ) {\n\t\tdefine('D.js', [], function(){ return defer; });\n\t} else if ( typeof module !== undefStr && module.exports ) {\n\t\tmodule.exports = defer;\n\t} else if ( typeof window !== undefStr ) {\n\t\tvar oldD = window.D;\n\t\t/**\n\t\t * restore global D variable to its previous value and return D to the user\n\t\t * @returns {Function}\n\t\t */\n\t\tdefer.noConflict = function(){\n\t\t\twindow.D = oldD;\n\t\t\treturn defer;\n\t\t};\n\t\twindow.D = defer;\n\t}\n})();\n\n}).call(this,require('_process'))\n\n},{\"_process\":1}],3:[function(require,module,exports){\nvar D = require('d.js');\n\nfunction serRequest(geolocate) {\n  var deferred = D();\n  $.ajax({\n      type: \"POST\",\n      url: '/coords/',\n      data: geolocate,\n      success: function(data) {\n        data = JSON.parse(data);\n        deferred.resolve(data);\n      },\n      error: function(jqXHR, textstatus, errorThrown) {\n          console.log('text status ' + textstatus + ', err ' + errorThrown);\n      }\n  });\n\n  return deferred.promise;\n}\n\nmodule.exports = serRequest;\n\n},{\"d.js\":2}],4:[function(require,module,exports){\nvar map;\n\nfunction offsetMap(latlng,offsetx,offsety) {\n  var scale = Math.pow(2, map.getZoom());\n  var nw = new google.maps.LatLng(\n      map.getBounds().getNorthEast().lat(),\n      map.getBounds().getSouthWest().lng()\n  );\n\n  var worldCoordinateCenter = map.getProjection().fromLatLngToPoint(latlng);\n  var pixelOffset = new google.maps.Point((offsetx/scale) || 0,(offsety/scale) ||0);\n\n  var worldCoordinateNewCenter = new google.maps.Point(\n      worldCoordinateCenter.x - pixelOffset.x,\n      worldCoordinateCenter.y + pixelOffset.y\n  );\n\n  var newCenter = map.getProjection().fromPointToLatLng(worldCoordinateNewCenter);\n\n  map.setCenter(newCenter);\n}\n\nfunction initMap(serRequest) {\n  map = new google.maps.Map(document.getElementById('map-canvas'), {\n    center: {lat: 41.850033, lng: -87.6500523},\n    zoom: 4\n  });\n  var input = document.getElementById('searchTextField');\n  //map.controls[google.maps.ControlPosition.TOP_LEFT].push(input);\n  var options = {\n    componentRestrictions: {country: 'us'}\n  };\n  autocomplete = new google.maps.places.Autocomplete(input, options);\n  var infowindow = new google.maps.InfoWindow({\n        maxWidth: 700\n  });\n  var marker = new google.maps.Marker({\n    map: map\n  });\n\n  marker.addListener('click', function(serRequest) {\n    infowindow.open(map, marker);\n  });\n\n  autocomplete.addListener('place_changed', function () {\n    infowindow.close();\n\n    var place = autocomplete.getPlace();\n    if (!place.geometry) {\n      return;\n    }\n    console.log(\"place:\",place);\n    console.log(place.address_components);\n\n    var geolocate = {\n      lat: place.geometry.location.lat(),\n      lng: place.geometry.location.lng(),\n      type: place.address_components[0].types[0],\n    };\n    console.log(geolocate.type, \"Place Geometry\",place.geometry.location);\n\n    if (place.geometry.viewport) {\n      map.fitBounds(place.geometry.viewport);\n    } else {\n      offsetMap(place.geometry.location,0,-700);\n      map.setZoom(17);\n    }\n\n    // Set the position of the marker using the place ID and location.\n    marker.setPlace({\n      placeId: place.place_id,\n      location: place.geometry.location\n    });\n    marker.setVisible(true);\n    infowindow.setContent(\n      '<div><strong>' + place.name + '</strong><br>' +\n      place.formatted_address +\n      '<br><br><strong>Race</strong><br>' +\n      \"<div class='race' style='height:350; width:900 ; display: inline-block;'><table class='left'></table></div>\" +\n      '<br><br><strong>Gender and Age</strong><br>' +\n      \"<div class='genderAge' style='height:350; display: inline-block;'><table class='left'></table></div>\" +\n      \"</div>\");\n\n    infowindow.open(map, marker);\n    serRequest(geolocate);\n  });\n\n  console.log(infowindow);\n\n\n}\n\nmodule.exports = initMap;\n\n},{}],5:[function(require,module,exports){\nvar initMap = require(\"./initMap\");\nvar request = require(\"./ajax\");\nvar plotTotal = require(\"./plotTotal\");\nvar plotRace = require(\"./plotRace\");\nvar plotGenderAge = require(\"./plotGenderAge\");\n\n\nvar bindedCreatePlot, needToRemove;\n\n$(window).resize(function(){\n  bindedCreatePlot();\n});\n\n console.log(typeof(initMap));\nfunction createPlot(censusData) {\n  var totalHTML = d3.select(\".total\");\n  var raceHTML = d3.select(\".race\");\n  var genderAgeHTML = d3.select(\".genderAge\");\n  //console.log(censusData);\n  var totalData = censusData.race.total;\n  var raceData = censusData.race;\n  var femaleData = censusData.femaleAge;\n  var maleData = censusData.maleAge;\n  console.log(maleData);\n\n  if (needToRemove) {\n    removePlot();\n  } else {\n    needToRemove = true;\n  }\n\n  plotTotal(totalHTML, totalData);\n  plotRace(raceHTML, raceData);\n  plotGenderAge(genderAgeHTML, [maleData,femaleData]);\n}\n\nfunction removePlot() {\n  d3.select(\".total\").select(\"h3\").remove();\n  d3.select(\".race\").select(\"table\").selectAll(\"tr\").remove();\n  d3.select(\".race\").select(\"svg\").remove();\n  d3.select(\".genderAge\").select(\"svg\").remove();\n}\n\n$(document).ready(function()  {\n  initMap(promiseChain);\n});\n\nfunction promiseChain(data) {\n  request(data)\n  .then(function(data) {\n    console.log(data);\n    bindedCreatePlot = createPlot.bind(null, data);\n    createPlot(data);\n  });\n}\n\n},{\"./ajax\":3,\"./initMap\":4,\"./plotGenderAge\":6,\"./plotRace\":7,\"./plotTotal\":8}],6:[function(require,module,exports){\nfunction plotGenderAge(div, genderAge) {\n  var keys = Object.keys(genderAge[0]);\n  keys.shift();\n  console.log(keys);\n  console.log(\"Age\", genderAge[0][keys[3]]);\n  console.log(\"MaleTotal\", genderAge[0].total, genderAge[0][\"total\"]);\n  var n = 2, // number of layers\n      m = 9, // number of samples per layer\n      stack = d3.layout.stack(),\n      layers = stack( d3.range(n).map( function(idx) {\n        return keys.map( function(d, i) {\n          //console.log(genderAge[idx][d])\n          return { x: i, y: Math.max(0, parseInt(genderAge[idx][d])) };\n        });\n      })),\n      yGroupMax = d3.max(layers, function(layer) { return d3.max(layer, function(d) { return d.y; }); }),\n      yStackMax = d3.max(layers, function(layer) { return d3.max(layer, function(d) { return d.y0 + d.y; }); });\n\n  var container = div.node().parentElement;\n\n  var color = d3.scale.linear()\n      .domain([0, n - 1])\n      .range([\"#aad\", \"#556\"]);\n\n  //Organizing the data for table.\n  var tableCategories = keys.slice();\n  tableCategories.unshift(\"header\");\n  tableCategories.push(\"Total\");\n\n  var mainSelection = div.select(\"table\").selectAll(\"tr\")\n      .data(tableCategories);\n\n  var tr = mainSelection.enter().append(\"tr\");\n\n  var selection = tr.selectAll(\"td\")\n      .data(function(d, i) {\n        if (!i) {\n\n          return [\n            \"Ages\",\n            \"Males\",\n            \"Females\",\n            \"Total\",\n          ];\n        } else if (d === \"Total\") {\n\n          return [\n            d,\n            genderAge[0].total,\n            genderAge[1].total,\n            genderAge[0].total + genderAge[1].total,\n          ];\n        }\n\n        return [\n          d,\n          genderAge[0][d],\n          genderAge[1][d],\n          genderAge[0][d]+genderAge[1][d],\n        ];\n      });\n  selection.enter().append(\"td\")\n      .text(function(d, i) {\n        console.log(d);\n        return d;\n      });\n\n  div.node().type = \"stack\";\n  console.log(div, div.node().type);\n  var margin = {top: 40, right: 40, bottom: 70, left: 10},\n      width = 200 - margin.left - margin.right,\n      height = (200) - margin.top - margin.bottom;\n\n  var x = d3.scale.ordinal()\n      .domain(keys)\n      .rangeRoundBands([0, width], 0.08);\n\n  var y = d3.scale.linear()\n      .domain([0, yStackMax])\n      .range([height, 0]);\n\n  var xAxis = d3.svg.axis()\n      .scale(x)\n      .tickSize(1)\n      .tickPadding(6)\n      .orient(\"bottom\");\n\n\n  var svg = div.append(\"svg\")\n      .attr(\"width\", width + margin.left + margin.right)\n      .attr(\"height\", height + margin.top + margin.bottom)\n    .append(\"g\")\n      .attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n  var layer = svg.selectAll(\".layer\")\n      .data(layers)\n    .enter().append(\"g\")\n      .attr(\"class\", \"layer\")\n      .style(\"fill\", function(d, i) { return color(i); });\n\n  var rect = layer.selectAll(\"rect\")\n      .data(function(d) { return d; })\n    .enter().append(\"rect\")\n      .attr(\"x\", function(d) {\n        console.log(x, x(keys[d.x]), d.x, d);\n        return x(keys[d.x]);\n      })\n      .attr(\"y\", height)\n      .attr(\"width\", x.rangeBand())\n      .attr(\"height\", 0);\n\n  rect.transition()\n      .delay(function(d, i) { return i * 10; })\n      .attr(\"y\", function(d) { return y(d.y0 + d.y); })\n      .attr(\"height\", function(d) { return y(d.y0) - y(d.y0 + d.y); });\n\n  svg.append(\"g\")\n      .attr(\"class\", \"x axis\")\n      .attr(\"transform\", \"translate(0,\" + height + \")\")\n      .call(xAxis)\n    .selectAll(\"text\")\n      .attr(\"y\", 0)\n      .attr(\"x\", 9)\n      .attr(\"dy\", \".35em\")\n      .attr(\"transform\", \"rotate(60)\")\n      .style(\"text-anchor\", \"start\");\n\n  var timeout = setTimeout(function() {\n    d3.select(\"input[value=\\\"grouped\\\"]\").property(\"checked\", true).each(change);\n  }, 2000);\n\n  function change(transitionStacked, transitionGrouped) {\n    //clearTimeout(timeout);\n    if (this.type === \"stack\") {\n      transitionGrouped();\n      this.type = \"group\";\n    }\n    else {\n      transitionStacked();\n      this.type = \"stack\";\n    }\n  }\n\n  function transitionGrouped(y, yGroupMax, x, rect, height, keys) {\n    y.domain([0, yGroupMax]);\n\n    rect.transition()\n        .duration(500)\n        .delay(function(d, i) { return i * 10; })\n        .attr(\"x\", function(d, i, j) { return x(keys[d.x]) + x.rangeBand() / n * j; })\n        .attr(\"width\", x.rangeBand() / n)\n      .transition()\n        .attr(\"y\", function(d) { return y(d.y); })\n        .attr(\"height\", function(d) { return height - y(d.y); });\n  }\n\n  function transitionStacked(y, yStackMax, x, rect, keys) {\n    y.domain([0, yStackMax]);\n\n    rect.transition()\n        .duration(500)\n        .delay(function(d, i) { return i * 10; })\n        .attr(\"y\", function(d) { return y(d.y0 + d.y); })\n        .attr(\"height\", function(d) { return y(d.y0) - y(d.y0 + d.y); })\n      .transition()\n        .attr(\"x\", function(d) { return x(keys[d.x]); })\n        .attr(\"width\", x.rangeBand());\n  }\n\n  div.on(\"click\", change.bind(div.node(),\n    transitionStacked.bind(null, y, yStackMax, x, rect, keys),\n    transitionGrouped.bind(null, y, yGroupMax, x, rect, height, keys)\n  ));\n  // Inspired by Lee Byron's test data generator.\n  function bumpLayer(n, o) {\n\n    function bump(a) {\n      var x = 1 / (0.1 + Math.random()),\n          y = 2 * Math.random() - 0.5,\n          z = 10 / (0.1 + Math.random());\n      for (var i = 0; i < n; i++) {\n        var w = (i / n - y) * z;\n        a[i] += x * Math.exp(-w * w);\n      }\n    }\n\n    var a = [], i;\n    for (i = 0; i < n; ++i) a[i] = o + o * Math.random();\n    for (i = 0; i < 5; ++i) bump(a);\n    return arr.map(function(d, i) { return {x: i, y: Math.max(0, d)}; });\n  }\n\n}\nmodule.exports = plotGenderAge;\n\n},{}],7:[function(require,module,exports){\nfunction plotRace(div, race) {\n  var keys = Object.keys(race).splice(1);\n\n  var data = keys.filter( function(key) {\n    return (key !== \"total\");\n  }).map( function(key){\n    //console.log(key);\n      return race[key];\n  });\n\n  var color = d3.scale.category20();\n\n  var selection = div.select(\"table\").selectAll(\"tr\")\n      .data(keys);\n  var tr = selection.enter().append(\"tr\");\n\n  tr.append(\"td\")\n      .text(\"HH\")\n      .style(\"background\", function(d, i) {\n        return color(i);\n      })\n      .style(\"color\", function(d, i) {\n        return color(i);\n      });\n\n  tr.append(\"td\").text( function(d, i) {\n    var str = d.split(\" \").map(function(elm) {\n      return elm[0].toUpperCase() + elm.slice(1);\n    }).join(\" \");\n\n    return \" \"+ str + \": \" + race[d];\n  });\n\n  var container = div.node().parentElement;\n  var width = 200 - 25,\n      height = 200 - 25,\n      outerRadius = height / 2 - 30,\n      innerRadius = outerRadius / 3;\n\n  var arc = d3.svg.arc()\n      .innerRadius(innerRadius)\n      .outerRadius(outerRadius);\n\n  var pie = d3.layout.pie();\n\n  var ease = d3.ease('cubic-in-out'),\n      duration = 2500;\n\n  var svg = div.append(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n  .append(\"g\")\n    .attr(\"transform\", \"translate(\" + width / 2 + \",\" + height / 2 + \")\");\n\n\n  var path = svg.selectAll(\"path\")\n      .data(data)\n    .enter().append(\"path\")\n      .style(\"fill\", function(d, i) {\n        //console.log(color.domain[i], color(i));\n        return color(i);\n      });\n\n  d3.timer(function(elapsed) {\n    var t = ease(1 - Math.abs((elapsed % duration) / duration - 0.5) * 2);\n    var arcs = pie.padAngle(0.06 * t)(data);\n\n    path\n        .data(arcs)\n        .attr(\"d\", arc);\n  });\n}\n\nmodule.exports = plotRace;\n\n},{}],8:[function(require,module,exports){\nfunction plotTotal(div, total) {\n  div.append(\"h3\").text(function(){\n    return \"Total Population: \" + total;\n  });\n}\n\nmodule.exports = plotTotal;\n\n},{}]},{},[5])\n\n","/**\n* attempt of a simple defer/promise library for mobile development\n* @author Jonathan Gotti < jgotti at jgotti dot net>\n* @since 2012-10\n* @version 0.7.3\n*/\n(function(undef){\n\t\"use strict\";\n\n\tvar nextTick\n\t\t, isFunc = function(f){ return ( typeof f === 'function' ); }\n\t\t, isArray = function(a){ return Array.isArray ? Array.isArray(a) : (a instanceof Array); }\n\t\t, isObjOrFunc = function(o){ return !!(o && (typeof o).match(/function|object/)); }\n\t\t, isNotVal = function(v){ return (v === false || v === undef || v === null); }\n\t\t, slice = function(a, offset){ return [].slice.call(a, offset); }\n\t\t, undefStr = 'undefined'\n\t\t, tErr = typeof TypeError === undefStr ? Error : TypeError\n\t;\n\tif ( (typeof process !== undefStr) && process.nextTick ) {\n\t\tnextTick = process.nextTick;\n\t} else if ( typeof MessageChannel !== undefStr ) {\n\t\tvar ntickChannel = new MessageChannel(), queue = [];\n\t\tntickChannel.port1.onmessage = function(){ queue.length && (queue.shift())(); };\n\t\tnextTick = function(cb){\n\t\t\tqueue.push(cb);\n\t\t\tntickChannel.port2.postMessage(0);\n\t\t};\n\t} else {\n\t\tnextTick = function(cb){ setTimeout(cb, 0); };\n\t}\n\tfunction rethrow(e){ nextTick(function(){ throw e;}); }\n\n\t/**\n\t * @typedef deferred\n\t * @property {promise} promise\n\t * @method resolve\n\t * @method fulfill\n\t * @method reject\n\t */\n\n\t/**\n\t * @typedef {function} fulfilled\n\t * @param {*} value promise resolved value\n\t * @returns {*} next promise resolution value\n\t */\n\n\t/**\n\t * @typedef {function} failed\n\t * @param {*} reason promise rejection reason\n\t * @returns {*} next promise resolution value or rethrow the reason\n\t */\n\n\t//-- defining unenclosed promise methods --//\n\t/**\n\t * same as then without failed callback\n\t * @param {fulfilled} fulfilled callback\n\t * @returns {promise} a new promise\n\t */\n\tfunction promise_success(fulfilled){ return this.then(fulfilled, undef); }\n\n\t/**\n\t * same as then with only a failed callback\n\t * @param {failed} failed callback\n\t * @returns {promise} a new promise\n\t */\n\tfunction promise_error(failed){ return this.then(undef, failed); }\n\n\n\t/**\n\t * same as then but fulfilled callback will receive multiple parameters when promise is fulfilled with an Array\n\t * @param {fulfilled} fulfilled callback\n\t * @param {failed} failed callback\n\t * @returns {promise} a new promise\n\t */\n\tfunction promise_apply(fulfilled, failed){\n\t\treturn this.then(\n\t\t\tfunction(a){\n\t\t\t\treturn isFunc(fulfilled) ? fulfilled.apply(null, isArray(a) ? a : [a]) : (defer.onlyFuncs ? a : fulfilled);\n\t\t\t}\n\t\t\t, failed || undef\n\t\t);\n\t}\n\n\t/**\n\t * cleanup method which will be always executed regardless fulfillment or rejection\n\t * @param {function} cb a callback called regardless of the fulfillment or rejection of the promise which will be called\n\t *                      when the promise is not pending anymore\n\t * @returns {promise} the same promise untouched\n\t */\n\tfunction promise_ensure(cb){\n\t\tfunction _cb(){ cb(); }\n\t\tthis.then(_cb, _cb);\n\t\treturn this;\n\t}\n\n\t/**\n\t * take a single callback which wait for an error as first parameter. other resolution values are passed as with the apply/spread method\n\t * @param {function} cb a callback called regardless of the fulfillment or rejection of the promise which will be called\n\t *                      when the promise is not pending anymore with error as first parameter if any as in node style\n\t *                      callback. Rest of parameters will be applied as with the apply method.\n\t * @returns {promise} a new promise\n\t */\n\tfunction promise_nodify(cb){\n\t\treturn this.then(\n\t\t\tfunction(a){\n\t\t\t\treturn isFunc(cb) ? cb.apply(null, isArray(a) ? a.splice(0,0,undefined) && a : [undefined,a]) : (defer.onlyFuncs ? a : cb);\n\t\t\t}\n\t\t\t, function(e){\n\t\t\t\treturn cb(e);\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t *\n\t * @param {function} [failed] without parameter will only rethrow promise rejection reason outside of the promise library on next tick\n\t *                            if passed a failed method then will call failed on rejection and throw the error again if failed didn't\n\t * @returns {promise} a new promise\n\t */\n\tfunction promise_rethrow(failed){\n\t\treturn this.then(\n\t\t\tundef\n\t\t\t, failed ? function(e){ failed(e); throw e; } : rethrow\n\t\t);\n\t}\n\n\t/**\n\t* @param {boolean} [alwaysAsync] if set force the async resolution for this promise independantly of the D.alwaysAsync option\n\t* @returns {deferred} defered object with property 'promise' and methods reject,fulfill,resolve (fulfill being an alias for resolve)\n\t*/\n\tvar defer = function (alwaysAsync){\n\t\tvar alwaysAsyncFn = (undef !== alwaysAsync ? alwaysAsync : defer.alwaysAsync) ? nextTick : function(fn){fn();}\n\t\t\t, status = 0 // -1 failed | 1 fulfilled\n\t\t\t, pendings = []\n\t\t\t, value\n\t\t\t/**\n\t\t\t * @typedef promise\n\t\t\t */\n\t\t\t, _promise  = {\n\t\t\t\t/**\n\t\t\t\t * @param {fulfilled|function} fulfilled callback\n\t\t\t\t * @param {failed|function} failed callback\n\t\t\t\t * @returns {promise} a new promise\n\t\t\t\t */\n\t\t\t\tthen: function(fulfilled, failed){\n\t\t\t\t\tvar d = defer();\n\t\t\t\t\tpendings.push([\n\t\t\t\t\t\tfunction(value){\n\t\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\t\tif( isNotVal(fulfilled)){\n\t\t\t\t\t\t\t\t\td.resolve(value);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\td.resolve(isFunc(fulfilled) ? fulfilled(value) : (defer.onlyFuncs ? value : fulfilled));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}catch(e){\n\t\t\t\t\t\t\t\td.reject(e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t, function(err){\n\t\t\t\t\t\t\tif ( isNotVal(failed) || ((!isFunc(failed)) && defer.onlyFuncs) ) {\n\t\t\t\t\t\t\t\td.reject(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( failed ) {\n\t\t\t\t\t\t\t\ttry{ d.resolve(isFunc(failed) ? failed(err) : failed); }catch(e){ d.reject(e);}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t]);\n\t\t\t\t\tstatus !== 0 && alwaysAsyncFn(execCallbacks);\n\t\t\t\t\treturn d.promise;\n\t\t\t\t}\n\n\t\t\t\t, success: promise_success\n\n\t\t\t\t, error: promise_error\n\t\t\t\t, otherwise: promise_error\n\n\t\t\t\t, apply: promise_apply\n\t\t\t\t, spread: promise_apply\n\n\t\t\t\t, ensure: promise_ensure\n\n\t\t\t\t, nodify: promise_nodify\n\n\t\t\t\t, rethrow: promise_rethrow\n\n\t\t\t\t, isPending: function(){ return status === 0; }\n\n\t\t\t\t, getStatus: function(){ return status; }\n\t\t\t}\n\t\t;\n\t\t_promise.toSource = _promise.toString = _promise.valueOf = function(){return value === undef ? this : value; };\n\n\n\t\tfunction execCallbacks(){\n\t\t\t/*jshint bitwise:false*/\n\t\t\tif ( status === 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar cbs = pendings, i = 0, l = cbs.length, cbIndex = ~status ? 0 : 1, cb;\n\t\t\tpendings = [];\n\t\t\tfor( ; i < l; i++ ){\n\t\t\t\t(cb = cbs[i][cbIndex]) && cb(value);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * fulfill deferred with given value\n\t\t * @param {*} val\n\t\t * @returns {deferred} this for method chaining\n\t\t */\n\t\tfunction _resolve(val){\n\t\t\tvar done = false;\n\t\t\tfunction once(f){\n\t\t\t\treturn function(x){\n\t\t\t\t\tif (done) {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdone = true;\n\t\t\t\t\t\treturn f(x);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\tif ( status ) {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tvar then = isObjOrFunc(val) && val.then;\n\t\t\t\tif ( isFunc(then) ) { // managing a promise\n\t\t\t\t\tif( val === _promise ){\n\t\t\t\t\t\tthrow new tErr(\"Promise can't resolve itself\");\n\t\t\t\t\t}\n\t\t\t\t\tthen.call(val, once(_resolve), once(_reject));\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tonce(_reject)(e);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\talwaysAsyncFn(function(){\n\t\t\t\tvalue = val;\n\t\t\t\tstatus = 1;\n\t\t\t\texecCallbacks();\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * reject deferred with given reason\n\t\t * @param {*} Err\n\t\t * @returns {deferred} this for method chaining\n\t\t */\n\t\tfunction _reject(Err){\n\t\t\tstatus || alwaysAsyncFn(function(){\n\t\t\t\ttry{ throw(Err); }catch(e){ value = e; }\n\t\t\t\tstatus = -1;\n\t\t\t\texecCallbacks();\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\t\treturn /**@type deferred */ {\n\t\t\tpromise:_promise\n\t\t\t,resolve:_resolve\n\t\t\t,fulfill:_resolve // alias\n\t\t\t,reject:_reject\n\t\t};\n\t};\n\n\tdefer.deferred = defer.defer = defer;\n\tdefer.nextTick = nextTick;\n\tdefer.alwaysAsync = true; // setting this will change default behaviour. use it only if necessary as asynchronicity will force some delay between your promise resolutions and is not always what you want.\n\t/**\n\t* setting onlyFuncs to false will break promises/A+ conformity by allowing you to pass non undefined/null values instead of callbacks\n\t* instead of just ignoring any non function parameters to then,success,error... it will accept non null|undefined values.\n\t* this will allow you shortcuts like promise.then('val','handled error'')\n\t* to be equivalent of promise.then(function(){ return 'val';},function(){ return 'handled error'})\n\t*/\n\tdefer.onlyFuncs = true;\n\n\t/**\n\t * return a fulfilled promise of given value (always async resolution)\n\t * @param {*} value\n\t * @returns {promise}\n\t */\n\tdefer.resolved = defer.fulfilled = function(value){ return defer(true).resolve(value).promise; };\n\n\t/**\n\t * return a rejected promise with given reason of rejection (always async rejection)\n\t * @param {*} reason\n\t * @returns {promise}\n\t */\n\tdefer.rejected = function(reason){ return defer(true).reject(reason).promise; };\n\n\t/**\n\t * return a promise with no resolution value which will be resolved in time ms (using setTimeout)\n\t * @param {int} [time] in ms default to 0\n\t * @returns {promise}\n\t */\n\tdefer.wait = function(time){\n\t\tvar d = defer();\n\t\tsetTimeout(d.resolve, time || 0);\n\t\treturn d.promise;\n\t};\n\n\t/**\n\t * return a promise for the return value of function call which will be fulfilled in delay ms or rejected if given fn throw an error\n\t * @param {*} fn to execute or value to return after given delay\n\t * @param {int} [delay] in ms default to 0\n\t * @returns {promise}\n\t */\n\tdefer.delay = function(fn, delay){\n\t\tvar d = defer();\n\t\tsetTimeout(function(){ try{ d.resolve(isFunc(fn) ? fn.apply(null) : fn); }catch(e){ d.reject(e); } }, delay || 0);\n\t\treturn d.promise;\n\t};\n\n\t/**\n\t * if given value is not a promise return a fulfilled promise resolved to given value\n\t * @param {*} promise a value or a promise\n\t * @returns {promise}\n\t */\n\tdefer.promisify = function(promise){\n\t\tif ( promise && isFunc(promise.then) ) { return promise;}\n\t\treturn defer.resolved(promise);\n\t};\n\n\tfunction multiPromiseResolver(callerArguments, returnPromises){\n\t\tvar promises = slice(callerArguments);\n\t\tif ( promises.length === 1 && isArray(promises[0]) ) {\n\t\t\tif(! promises[0].length ){\n\t\t\t\treturn defer.fulfilled([]);\n\t\t\t}\n\t\t\tpromises = promises[0];\n\t\t}\n\t\tvar args = []\n\t\t\t, d = defer()\n\t\t\t, c = promises.length\n\t\t;\n\t\tif ( !c ) {\n\t\t\td.resolve(args);\n\t\t} else {\n\t\t\tvar resolver = function(i){\n\t\t\t\tpromises[i] = defer.promisify(promises[i]);\n\t\t\t\tpromises[i].then(\n\t\t\t\t\tfunction(v){\n\t\t\t\t\t\targs[i] = returnPromises ? promises[i] : v;\n\t\t\t\t\t\t(--c) || d.resolve(args);\n\t\t\t\t\t}\n\t\t\t\t\t, function(e){\n\t\t\t\t\t\tif( ! returnPromises ){\n\t\t\t\t\t\t\td.reject(e);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\targs[i] = promises[i];\n\t\t\t\t\t\t\t(--c) || d.resolve(args);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t};\n\t\t\tfor( var i = 0, l = c; i < l; i++ ){\n\t\t\t\tresolver(i);\n\t\t\t}\n\t\t}\n\t\treturn d.promise;\n\t}\n\n\tfunction sequenceZenifier(promise, zenValue){\n\t\treturn promise.then(isFunc(zenValue) ? zenValue : function(){return zenValue;});\n\t}\n\tfunction sequencePromiseResolver(callerArguments){\n\t\tvar funcs = slice(callerArguments);\n\t\tif ( funcs.length === 1 && isArray(funcs[0]) ) {\n\t\t\tfuncs = funcs[0];\n\t\t}\n\t\tvar d = defer(), i=0, l=funcs.length, promise = defer.resolved();\n\t\tfor(; i<l; i++){\n\t\t\tpromise = sequenceZenifier(promise, funcs[i]);\n\t\t}\n\t\td.resolve(promise);\n\t\treturn d.promise;\n\t}\n\n\t/**\n\t * return a promise for all given promises / values.\n\t * the returned promises will be fulfilled with a list of resolved value.\n\t * if any given promise is rejected then on the first rejection the returned promised will be rejected with the same reason\n\t * @param {array|...*} [promise] can be a single array of promise/values as first parameter or a list of direct parameters promise/value\n\t * @returns {promise} of a list of given promise resolution value\n\t */\n\tdefer.all = function(){ return multiPromiseResolver(arguments,false); };\n\n\t/**\n\t * return an always fulfilled promise of array<promise> list of promises/values regardless they resolve fulfilled or rejected\n\t * @param {array|...*} [promise] can be a single array of promise/values as first parameter or a list of direct parameters promise/value\n\t *                     (non promise values will be promisified)\n\t * @returns {promise} of the list of given promises\n\t */\n\tdefer.resolveAll = function(){ return multiPromiseResolver(arguments,true); };\n\n\t/**\n\t* execute given function in sequence passing their returned values to the next one in sequence.\n\t* You can pass values or promise instead of functions they will be passed in the sequence as if a function returned them.\n\t* if any function throw an error or a rejected promise the final returned promise will be rejected with that reason.\n\t* @param {array|...*} [function] list of function to call in sequence receiving previous one as a parameter\n\t*                     (non function values will be treated as if returned by a function)\n\t* @returns {promise} of the list of given promises\n\t*/\n\tdefer.sequence = function(){ return sequencePromiseResolver(arguments); };\n\n\t/**\n\t * transform a typical nodejs async method awaiting a callback as last parameter, receiving error as first parameter to a function that\n\t * will return a promise instead. the returned promise will resolve with normal callback value minus the first error parameter on\n\t * fulfill and will be rejected with that error as reason in case of error.\n\t * @param {object} [subject] optional subject of the method to encapsulate\n\t * @param {function} fn the function to encapsulate if the normal callback should receive more than a single parameter (minus the error)\n\t *                      the promise will resolve with the list or parameters as fulfillment value. If only one parameter is sent to the\n\t *                      callback then it will be used as the resolution value.\n\t * @returns {Function}\n\t */\n\tdefer.nodeCapsule = function(subject, fn){\n\t\tif ( !fn ) {\n\t\t\tfn = subject;\n\t\t\tsubject = void(0);\n\t\t}\n\t\treturn function(){\n\t\t\tvar d = defer(), args = slice(arguments);\n\t\t\targs.push(function(err, res){\n\t\t\t\terr ? d.reject(err) : d.resolve(arguments.length > 2 ? slice(arguments, 1) : res);\n\t\t\t});\n\t\t\ttry{\n\t\t\t\tfn.apply(subject, args);\n\t\t\t}catch(e){\n\t\t\t\td.reject(e);\n\t\t\t}\n\t\t\treturn d.promise;\n\t\t};\n\t};\n\n\t/*global define*/\n\tif ( typeof define === 'function' && define.amd ) {\n\t\tdefine('D.js', [], function(){ return defer; });\n\t} else if ( typeof module !== undefStr && module.exports ) {\n\t\tmodule.exports = defer;\n\t} else if ( typeof window !== undefStr ) {\n\t\tvar oldD = window.D;\n\t\t/**\n\t\t * restore global D variable to its previous value and return D to the user\n\t\t * @returns {Function}\n\t\t */\n\t\tdefer.noConflict = function(){\n\t\t\twindow.D = oldD;\n\t\t\treturn defer;\n\t\t};\n\t\twindow.D = defer;\n\t}\n})();\n","var D = require('d.js');\n\nfunction serRequest(geolocate) {\n  var deferred = D();\n  $.ajax({\n      type: \"POST\",\n      url: '/coords/',\n      data: geolocate,\n      success: function(data) {\n        data = JSON.parse(data);\n        deferred.resolve(data);\n      },\n      error: function(jqXHR, textstatus, errorThrown) {\n          console.log('text status ' + textstatus + ', err ' + errorThrown);\n      }\n  });\n\n  return deferred.promise;\n}\n\nmodule.exports = serRequest;\n","var map;\n\nfunction offsetMap(latlng,offsetx,offsety) {\n  var scale = Math.pow(2, map.getZoom());\n  var nw = new google.maps.LatLng(\n      map.getBounds().getNorthEast().lat(),\n      map.getBounds().getSouthWest().lng()\n  );\n\n  var worldCoordinateCenter = map.getProjection().fromLatLngToPoint(latlng);\n  var pixelOffset = new google.maps.Point((offsetx/scale) || 0,(offsety/scale) ||0);\n\n  var worldCoordinateNewCenter = new google.maps.Point(\n      worldCoordinateCenter.x - pixelOffset.x,\n      worldCoordinateCenter.y + pixelOffset.y\n  );\n\n  var newCenter = map.getProjection().fromPointToLatLng(worldCoordinateNewCenter);\n\n  map.setCenter(newCenter);\n}\n\nfunction initMap(serRequest) {\n  map = new google.maps.Map(document.getElementById('map-canvas'), {\n    center: {lat: 41.850033, lng: -87.6500523},\n    zoom: 4\n  });\n  var input = document.getElementById('searchTextField');\n  //map.controls[google.maps.ControlPosition.TOP_LEFT].push(input);\n  var options = {\n    componentRestrictions: {country: 'us'}\n  };\n  autocomplete = new google.maps.places.Autocomplete(input, options);\n  var infowindow = new google.maps.InfoWindow({\n        maxWidth: 700\n  });\n  var marker = new google.maps.Marker({\n    map: map\n  });\n\n  marker.addListener('click', function(serRequest) {\n    infowindow.open(map, marker);\n  });\n\n  autocomplete.addListener('place_changed', function () {\n    infowindow.close();\n\n    var place = autocomplete.getPlace();\n    if (!place.geometry) {\n      return;\n    }\n    console.log(\"place:\",place);\n    console.log(place.address_components);\n\n    var geolocate = {\n      lat: place.geometry.location.lat(),\n      lng: place.geometry.location.lng(),\n      type: place.address_components[0].types[0],\n    };\n    console.log(geolocate.type, \"Place Geometry\",place.geometry.location);\n\n    if (place.geometry.viewport) {\n      map.fitBounds(place.geometry.viewport);\n    } else {\n      offsetMap(place.geometry.location,0,-700);\n      map.setZoom(17);\n    }\n\n    // Set the position of the marker using the place ID and location.\n    marker.setPlace({\n      placeId: place.place_id,\n      location: place.geometry.location\n    });\n    marker.setVisible(true);\n    infowindow.setContent(\n      '<div><strong>' + place.name + '</strong><br>' +\n      place.formatted_address +\n      '<br><br><strong>Race</strong><br>' +\n      \"<div class='race' style='height:350; width:900 ; display: inline-block;'><table class='left'></table></div>\" +\n      '<br><br><strong>Gender and Age</strong><br>' +\n      \"<div class='genderAge' style='height:350; display: inline-block;'><table class='left'></table></div>\" +\n      \"</div>\");\n\n    infowindow.open(map, marker);\n    serRequest(geolocate);\n  });\n\n  console.log(infowindow);\n\n\n}\n\nmodule.exports = initMap;\n","var initMap = require(\"./initMap\");\nvar request = require(\"./ajax\");\nvar plotTotal = require(\"./plotTotal\");\nvar plotRace = require(\"./plotRace\");\nvar plotGenderAge = require(\"./plotGenderAge\");\n\n\nvar bindedCreatePlot, needToRemove;\n\n$(window).resize(function(){\n  bindedCreatePlot();\n});\n\n console.log(typeof(initMap));\nfunction createPlot(censusData) {\n  var totalHTML = d3.select(\".total\");\n  var raceHTML = d3.select(\".race\");\n  var genderAgeHTML = d3.select(\".genderAge\");\n  //console.log(censusData);\n  var totalData = censusData.race.total;\n  var raceData = censusData.race;\n  var femaleData = censusData.femaleAge;\n  var maleData = censusData.maleAge;\n  console.log(maleData);\n\n  if (needToRemove) {\n    removePlot();\n  } else {\n    needToRemove = true;\n  }\n\n  plotTotal(totalHTML, totalData);\n  plotRace(raceHTML, raceData);\n  plotGenderAge(genderAgeHTML, [maleData,femaleData]);\n}\n\nfunction removePlot() {\n  d3.select(\".total\").select(\"h3\").remove();\n  d3.select(\".race\").select(\"table\").selectAll(\"tr\").remove();\n  d3.select(\".race\").select(\"svg\").remove();\n  d3.select(\".genderAge\").select(\"svg\").remove();\n}\n\n$(document).ready(function()  {\n  initMap(promiseChain);\n});\n\nfunction promiseChain(data) {\n  request(data)\n  .then(function(data) {\n    console.log(data);\n    bindedCreatePlot = createPlot.bind(null, data);\n    createPlot(data);\n  });\n}\n","function plotGenderAge(div, genderAge) {\n  var keys = Object.keys(genderAge[0]);\n  keys.shift();\n  console.log(keys);\n  console.log(\"Age\", genderAge[0][keys[3]]);\n  console.log(\"MaleTotal\", genderAge[0].total, genderAge[0][\"total\"]);\n  var n = 2, // number of layers\n      m = 9, // number of samples per layer\n      stack = d3.layout.stack(),\n      layers = stack( d3.range(n).map( function(idx) {\n        return keys.map( function(d, i) {\n          //console.log(genderAge[idx][d])\n          return { x: i, y: Math.max(0, parseInt(genderAge[idx][d])) };\n        });\n      })),\n      yGroupMax = d3.max(layers, function(layer) { return d3.max(layer, function(d) { return d.y; }); }),\n      yStackMax = d3.max(layers, function(layer) { return d3.max(layer, function(d) { return d.y0 + d.y; }); });\n\n  var container = div.node().parentElement;\n\n  var color = d3.scale.linear()\n      .domain([0, n - 1])\n      .range([\"#aad\", \"#556\"]);\n\n  //Organizing the data for table.\n  var tableCategories = keys.slice();\n  tableCategories.unshift(\"header\");\n  tableCategories.push(\"Total\");\n\n  var mainSelection = div.select(\"table\").selectAll(\"tr\")\n      .data(tableCategories);\n\n  var tr = mainSelection.enter().append(\"tr\");\n\n  var selection = tr.selectAll(\"td\")\n      .data(function(d, i) {\n        if (!i) {\n\n          return [\n            \"Ages\",\n            \"Males\",\n            \"Females\",\n            \"Total\",\n          ];\n        } else if (d === \"Total\") {\n\n          return [\n            d,\n            genderAge[0].total,\n            genderAge[1].total,\n            genderAge[0].total + genderAge[1].total,\n          ];\n        }\n\n        return [\n          d,\n          genderAge[0][d],\n          genderAge[1][d],\n          genderAge[0][d]+genderAge[1][d],\n        ];\n      });\n  selection.enter().append(\"td\")\n      .text(function(d, i) {\n        console.log(d);\n        return d;\n      });\n\n  div.node().type = \"stack\";\n  console.log(div, div.node().type);\n  var margin = {top: 40, right: 40, bottom: 70, left: 10},\n      width = 200 - margin.left - margin.right,\n      height = (200) - margin.top - margin.bottom;\n\n  var x = d3.scale.ordinal()\n      .domain(keys)\n      .rangeRoundBands([0, width], 0.08);\n\n  var y = d3.scale.linear()\n      .domain([0, yStackMax])\n      .range([height, 0]);\n\n  var xAxis = d3.svg.axis()\n      .scale(x)\n      .tickSize(1)\n      .tickPadding(6)\n      .orient(\"bottom\");\n\n\n  var svg = div.append(\"svg\")\n      .attr(\"width\", width + margin.left + margin.right)\n      .attr(\"height\", height + margin.top + margin.bottom)\n    .append(\"g\")\n      .attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n  var layer = svg.selectAll(\".layer\")\n      .data(layers)\n    .enter().append(\"g\")\n      .attr(\"class\", \"layer\")\n      .style(\"fill\", function(d, i) { return color(i); });\n\n  var rect = layer.selectAll(\"rect\")\n      .data(function(d) { return d; })\n    .enter().append(\"rect\")\n      .attr(\"x\", function(d) {\n        console.log(x, x(keys[d.x]), d.x, d);\n        return x(keys[d.x]);\n      })\n      .attr(\"y\", height)\n      .attr(\"width\", x.rangeBand())\n      .attr(\"height\", 0);\n\n  rect.transition()\n      .delay(function(d, i) { return i * 10; })\n      .attr(\"y\", function(d) { return y(d.y0 + d.y); })\n      .attr(\"height\", function(d) { return y(d.y0) - y(d.y0 + d.y); });\n\n  svg.append(\"g\")\n      .attr(\"class\", \"x axis\")\n      .attr(\"transform\", \"translate(0,\" + height + \")\")\n      .call(xAxis)\n    .selectAll(\"text\")\n      .attr(\"y\", 0)\n      .attr(\"x\", 9)\n      .attr(\"dy\", \".35em\")\n      .attr(\"transform\", \"rotate(60)\")\n      .style(\"text-anchor\", \"start\");\n\n  var timeout = setTimeout(function() {\n    d3.select(\"input[value=\\\"grouped\\\"]\").property(\"checked\", true).each(change);\n  }, 2000);\n\n  function change(transitionStacked, transitionGrouped) {\n    //clearTimeout(timeout);\n    if (this.type === \"stack\") {\n      transitionGrouped();\n      this.type = \"group\";\n    }\n    else {\n      transitionStacked();\n      this.type = \"stack\";\n    }\n  }\n\n  function transitionGrouped(y, yGroupMax, x, rect, height, keys) {\n    y.domain([0, yGroupMax]);\n\n    rect.transition()\n        .duration(500)\n        .delay(function(d, i) { return i * 10; })\n        .attr(\"x\", function(d, i, j) { return x(keys[d.x]) + x.rangeBand() / n * j; })\n        .attr(\"width\", x.rangeBand() / n)\n      .transition()\n        .attr(\"y\", function(d) { return y(d.y); })\n        .attr(\"height\", function(d) { return height - y(d.y); });\n  }\n\n  function transitionStacked(y, yStackMax, x, rect, keys) {\n    y.domain([0, yStackMax]);\n\n    rect.transition()\n        .duration(500)\n        .delay(function(d, i) { return i * 10; })\n        .attr(\"y\", function(d) { return y(d.y0 + d.y); })\n        .attr(\"height\", function(d) { return y(d.y0) - y(d.y0 + d.y); })\n      .transition()\n        .attr(\"x\", function(d) { return x(keys[d.x]); })\n        .attr(\"width\", x.rangeBand());\n  }\n\n  div.on(\"click\", change.bind(div.node(),\n    transitionStacked.bind(null, y, yStackMax, x, rect, keys),\n    transitionGrouped.bind(null, y, yGroupMax, x, rect, height, keys)\n  ));\n  // Inspired by Lee Byron's test data generator.\n  function bumpLayer(n, o) {\n\n    function bump(a) {\n      var x = 1 / (0.1 + Math.random()),\n          y = 2 * Math.random() - 0.5,\n          z = 10 / (0.1 + Math.random());\n      for (var i = 0; i < n; i++) {\n        var w = (i / n - y) * z;\n        a[i] += x * Math.exp(-w * w);\n      }\n    }\n\n    var a = [], i;\n    for (i = 0; i < n; ++i) a[i] = o + o * Math.random();\n    for (i = 0; i < 5; ++i) bump(a);\n    return arr.map(function(d, i) { return {x: i, y: Math.max(0, d)}; });\n  }\n\n}\nmodule.exports = plotGenderAge;\n","function plotRace(div, race) {\n  var keys = Object.keys(race).splice(1);\n\n  var data = keys.filter( function(key) {\n    return (key !== \"total\");\n  }).map( function(key){\n    //console.log(key);\n      return race[key];\n  });\n\n  var color = d3.scale.category20();\n\n  var selection = div.select(\"table\").selectAll(\"tr\")\n      .data(keys);\n  var tr = selection.enter().append(\"tr\");\n\n  tr.append(\"td\")\n      .text(\"HH\")\n      .style(\"background\", function(d, i) {\n        return color(i);\n      })\n      .style(\"color\", function(d, i) {\n        return color(i);\n      });\n\n  tr.append(\"td\").text( function(d, i) {\n    var str = d.split(\" \").map(function(elm) {\n      return elm[0].toUpperCase() + elm.slice(1);\n    }).join(\" \");\n\n    return \" \"+ str + \": \" + race[d];\n  });\n\n  var container = div.node().parentElement;\n  var width = 200 - 25,\n      height = 200 - 25,\n      outerRadius = height / 2 - 30,\n      innerRadius = outerRadius / 3;\n\n  var arc = d3.svg.arc()\n      .innerRadius(innerRadius)\n      .outerRadius(outerRadius);\n\n  var pie = d3.layout.pie();\n\n  var ease = d3.ease('cubic-in-out'),\n      duration = 2500;\n\n  var svg = div.append(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n  .append(\"g\")\n    .attr(\"transform\", \"translate(\" + width / 2 + \",\" + height / 2 + \")\");\n\n\n  var path = svg.selectAll(\"path\")\n      .data(data)\n    .enter().append(\"path\")\n      .style(\"fill\", function(d, i) {\n        //console.log(color.domain[i], color(i));\n        return color(i);\n      });\n\n  d3.timer(function(elapsed) {\n    var t = ease(1 - Math.abs((elapsed % duration) / duration - 0.5) * 2);\n    var arcs = pie.padAngle(0.06 * t)(data);\n\n    path\n        .data(arcs)\n        .attr(\"d\", arc);\n  });\n}\n\nmodule.exports = plotRace;\n","function plotTotal(div, total) {\n  div.append(\"h3\").text(function(){\n    return \"Total Population: \" + total;\n  });\n}\n\nmodule.exports = plotTotal;\n"],"sourceRoot":"/source/"}